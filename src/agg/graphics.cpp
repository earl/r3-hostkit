//exported functions
#include "agg_graphics.h"
//include "words-draw.h"	// Auto-generated by gen-draw-words.r
#undef IS_ERROR
//include "agg_truetype_text.h"

//extern "C" void Reb_Print(REBYTE *fmt, ...);//output just for testing
//extern "C" void* Rich_Text;
//extern "C" REBINT Text_Gob(void *graphics, REBSER *gob);
extern "C" REBINT Draw_Gob(void *graphics, REBSER *block, REBSER *args);

namespace agg
{
	extern "C" void agg_box(void* gr, REBPAR* p1, REBPAR* p2, REBDEC r)
	{
		if (r) {
			((agg_graphics*)gr)->agg_rounded_rect(p1->x, p1->y, p2->x, p2->y, r);
		} else {
			((agg_graphics*)gr)->agg_box(p1->x, p1->y, p2->x, p2->y);
		}
	}

	extern "C" void agg_circle(void* gr, REBPAR* p1, REBDEC rx, REBDEC ry)
	{
		((agg_graphics*)gr)->agg_ellipse(p1->x, p1->y, rx, ry);
	}

	extern "C" void agg_pen(void* gr, REBYTE* col, REBSER* img)
	{
//		if (img){
//			((agg_graphics*)gr)->agg_pen(0, 0, 0, 255, IMG_DATA(img), IMG_WIDE(img), IMG_HIGH(img));
//			return;
//		}

		if (col)
			((agg_graphics*)gr)->agg_pen(col[0], col[1], col[2], 255 - col[3]);
		else
			((agg_graphics*)gr)->agg_pen(0,0,0,0);

	}

	extern "C" void agg_fill_pen(void* gr, REBYTE* col)
	{
		if (col)
			((agg_graphics*)gr)->agg_fill_pen(col[0], col[1], col[2], 255 - col[3]);
		else
			((agg_graphics*)gr)->agg_fill_pen(0, 0, 0, 0);

	}

	extern "C" void agg_begin_poly (void* gr, REBDEC x,  REBDEC y)
	{
		((agg_graphics*)gr)->agg_begin_poly(x, y);
	}

	extern "C" void agg_add_vertex (void* gr, REBDEC x,  REBDEC y)
	{
		((agg_graphics*)gr)->agg_add_vertex(x, y);
	}


#ifdef ndef
	extern "C" REBINT Draw_Image(REBSER *image, REBSER *block)
	{
		int w = IMG_WIDE(image);
		int h = IMG_HIGH(image);

		agg_graphics::ren_buf renbuf(IMG_DATA(image), w, h, w * 4);
		agg_graphics::pixfmt pixf(renbuf);
		agg_graphics::ren_base rb_win(pixf);

		agg_graphics* graphics = new agg_graphics(&renbuf, w, h, 0, 0);

		REBSER *args = 0;

		REBINT result = Draw_Gob(graphics, block, args);
		
		if (result < 0) goto do_cleanup;

		result = graphics->agg_render(rb_win);

	do_cleanup:
		delete graphics;

		return result;
	}

	extern "C" void agg_get_size(void* gr, REBPAR* p)
	{
		((agg_graphics*)gr)->agg_size(p);
	}

	extern "C" void agg_anti_alias(void* gr, REBINT mode)
	{
		((agg_graphics*)gr)->agg_anti_alias(mode!=0);
	}

	extern "C" void agg_arc(void* gr, REBPAR* c, REBPAR* r, REBDEC ang1, REBDEC ang2, REBINT closed)
	{
		((agg_graphics*)gr)->agg_arc(c->x, c->y, r->x, r->y, ang1, ang2, closed);
	}

	extern "C" void agg_arrow(void* gr, REBYTE* c, REBPAR* ht)
	{
		((agg_graphics*)gr)->agg_arrows(c, ht->x, ht->y);
	}

	extern "C" void agg_clip(void* gr, REBPAR* p1, REBPAR* p2)
	{
		((agg_graphics*)gr)->agg_set_clip(p1->x, p1->y, p2->x, p2->y);
	}

	extern "C" void agg_curve3(void* gr, REBPAR* p1, REBPAR* p2, REBPAR* p3, REBPAR* p4)
	{
		((agg_graphics*)gr)->agg_curve3(p1->x, p1->y, p2->x, p2->y, p3->x, p3->y);
	}

	extern "C" void agg_curve4(void* gr, REBPAR* p1, REBPAR* p2, REBPAR* p3, REBPAR* p4)
	{
		((agg_graphics*)gr)->agg_curve4(p1->x, p1->y, p2->x, p2->y, p3->x, p3->y, p4->x, p4->y);
	}

	extern "C" void agg_ellipse(void* gr, REBPAR* p1, REBPAR* p2)
	{
		REBINT rx = p2->x/2;
		REBINT ry = p2->y/2;
		((agg_graphics*)gr)->agg_ellipse(p1->x+rx, p1->y+ry, rx, ry);
	}

	extern "C" void agg_effect(void* gr, REBPAR* p1, REBPAR* p2, REBSER* block)
	{
		((agg_graphics*)gr)->agg_effect(p1, p2, block);
	}

	extern "C" void agg_end_spline (void* gr, REBINT step, REBINT closed)
	{
		((agg_graphics*)gr)->agg_end_bspline(step, closed);
	}

	extern "C" void agg_end_poly (void* gr)
	{
		((agg_graphics*)gr)->agg_end_poly();
	}

	extern "C" void agg_fill_image_pen(void* gr, REBSER* img)
	{
		((agg_graphics*)gr)->agg_fill_pen(0, 0, 0, 255, IMG_DATA(img), IMG_WIDE(img), IMG_HIGH(img));
	}

	extern "C" void agg_fill_rule(void* gr, REBINT mode)
	{
		((agg_graphics*)gr)->agg_fill_rule((agg::filling_rule_e)mode);
	}

	extern "C" void agg_gamma(void* gr, REBDEC gamma)
	{
		((agg_graphics*)gr)->agg_set_gamma(gamma);
	}

	extern "C" void agg_gradient_pen(void* gr, REBINT gradtype, REBPAR* oft, REBDEC begin, REBDEC end, REBDEC ang, REBDEC scX,REBDEC scY, unsigned char *colors, REBDEC* offsets, REBINT mode){
		((agg_graphics*)gr)->agg_gradient_pen(gradtype, oft->x, oft->y, begin, end, ang, scX, scY, colors, offsets, mode);
	}

	extern "C" void agg_invert_matrix(void* gr)
	{
		((agg_graphics*)gr)->agg_invert_mtx();
	}

	extern "C" void agg_image(void* gr, REBSER* img, REBPAR* offset, REBYTE* key, REBINT border, REBINT pattern)
	{
		((agg_graphics*)gr)->agg_image(IMG_DATA(img), offset->x, offset->y, IMG_WIDE(img), IMG_HIGH(img), border, key[0], key[1], key[2], 255 - key[3]);
	}

	extern "C" void agg_image_perspective(void* gr, REBSER* img, REBPAR* p1, REBYTE* key, REBINT border, REBINT pattern, REBINT ox, REBINT oy, REBINT pw, REBINT ph , REBPAR* p2,REBPAR* p3,REBPAR* p4, REBCNT args)
	{
		((agg_graphics*)gr)->agg_begin_poly(p1->x, p1->y);
		switch (args){
			case 10: //scaled
				((agg_graphics*)gr)->agg_add_vertex(p2->x, p1->y);
				((agg_graphics*)gr)->agg_add_vertex(p2->x, p2->y);
				((agg_graphics*)gr)->agg_add_vertex(p1->x, p2->y);
				break;
			case 11:
				((agg_graphics*)gr)->agg_add_vertex(p2->x, p2->y);
				((agg_graphics*)gr)->agg_add_vertex(p3->x, p3->y);
				((agg_graphics*)gr)->agg_add_vertex(p1->x, p3->y);
				break;
			case 12: //perspective
				((agg_graphics*)gr)->agg_add_vertex(p2->x, p2->y);
				((agg_graphics*)gr)->agg_add_vertex(p3->x, p3->y);
				((agg_graphics*)gr)->agg_add_vertex(p4->x, p4->y);
				break;

		}
		((agg_graphics*)gr)->agg_end_poly_img(IMG_DATA(img), IMG_WIDE(img), IMG_HIGH(img), pw, ph, ox, oy, border, pattern, key[0], key[1], key[2],255 - key[3]);

	}


	extern "C" void agg_image_filter(void* gr, REBINT type, REBINT mode, REBDEC blur)
	{
		((agg_graphics*)gr)->agg_image_filter(type, mode, blur);
	}

	extern "C" void agg_line(void* gr, REBPAR* p1, REBPAR* p2)
	{
		((agg_graphics*)gr)->agg_line(p1->x, p1->y, p2->x, p2->y);
	}

	extern "C" void agg_line_cap(void* gr, REBINT mode)
	{
		((agg_graphics*)gr)->agg_stroke_cap((line_cap_e)mode);
	}

	extern "C" void agg_line_join(void* gr, REBINT mode)
	{
		((agg_graphics*)gr)->agg_stroke_join((line_join_e)mode);
		((agg_graphics*)gr)->agg_dash_join((line_join_e)mode);
	}

	extern "C" void agg_line_pattern(void* gr, REBYTE* col, REBDEC* patterns)
	{
		((agg_graphics*)gr)->agg_line_pattern(col, patterns); 
	}

	extern "C" void agg_line_width(void* gr, REBDEC width, REBINT mode)
	{
		((agg_graphics*)gr)->agg_line_width(width, mode);
	}

	extern "C" void agg_matrix(void* gr, REBSER* mtx)
	{
		REBVAL *slot = BLK_HEAD(mtx);
		REBCNT len = SERIES_TAIL(mtx) ,i, num = 0;

		REBDEC* matrix = new REBDEC[6];
		for (i = 0;i<len;i++){
			if (IS_DECIMAL(slot+i))
				matrix[i] = VAL_DECIMAL(slot+i);
			else if (IS_INTEGER(slot+i))
				matrix[i] = VAL_INT32(slot+i);
			else
				return;
			num++;
		}

		if (num != 6) return;

		((agg_graphics*)gr)->agg_set_mtx(matrix);

		delete[] matrix;
	}


	extern "C" void agg_polygon(void* gr, REBPAR* p1, REBPAR* p2, REBPAR* p3)
	{

	}

	extern "C" void agg_pop_matrix(void* gr)
	{
		((agg_graphics*)gr)->agg_pop_mtx();
	}

	extern "C" void agg_push_matrix(void* gr)
	{
		((agg_graphics*)gr)->agg_push_mtx();
	}

	extern "C" void agg_reset_gradient_pen(void* gr)
	{
		((agg_graphics*)gr)->agg_reset_gradient_pen();
	}

	extern "C" void agg_reset_matrix(void* gr)
	{
		((agg_graphics*)gr)->agg_reset_mtx();
	}

	extern "C" void agg_rotate(void* gr, REBDEC ang)
	{
		((agg_graphics*)gr)->agg_rotate(ang);
	}

	extern "C" void agg_scale(void* gr, REBDEC scx, REBDEC scy)
	{
		((agg_graphics*)gr)->agg_scale(scx,scy);
	}

	extern "C" void agg_skew(void* gr, REBDEC sx, REBDEC sy)
	{
		((agg_graphics*)gr)->agg_skew(sx, sy);
	}

	extern "C" void agg_spline(void* gr, REBINT seg, REBINT closed, REBPAR* p1, REBPAR* p2)
	{

	}

	extern "C" REBINT agg_text(void* gr, REBINT mode, REBPAR* p1, REBPAR* p2, REBSER* block)
	{
		return ((agg_graphics*)gr)->agg_text(mode, p1, p2, block);
	}

	extern "C" void agg_transform(void* gr, REBDEC ang, REBPAR* ctr, REBDEC scx, REBDEC scy, REBPAR* oft)
	{
		((agg_graphics*)gr)->agg_transform(ang, ctr->x, ctr->y, scx,scy, oft->x, oft->y);
	}

	extern "C" void agg_translate(void* gr, REBPAR* p)
	{
		((agg_graphics*)gr)->agg_translate(p->x, p->y);
	}

	extern "C" void agg_triangle(void* gr, REBPAR* p1, REBPAR* p2, REBPAR* p3, REBYTE* c1, REBYTE* c2, REBYTE* c3, REBDEC dilation)
	{
		((agg_graphics*)gr)->agg_gtriangle(p1, p2, p3, c1, c2, c3, dilation);
	}


	//SHAPE functions
	extern "C" void agg_path_open(void* gr)
	{
		((agg_graphics*)gr)->agg_begin_path();
	}

	extern "C" void agg_path_close(void* gr)
	{
		((agg_graphics*)gr)->agg_path_close();
	}


	extern "C" void agg_path_arc(void* gr, REBINT rel, REBPAR* p, REBDEC rx, REBDEC ry, REBDEC ang, REBINT sweep, REBINT large)
	{
		((agg_graphics*)gr)->agg_path_arc(rel, rx, ry, ang, large, sweep, p->x, p->y); 
	}

	extern "C" void agg_path_curv(void* gr, REBINT rel, REBPAR* p1, REBPAR* p2)
	{
		((agg_graphics*)gr)->agg_path_cubic_curve_to(rel, p1->x, p1->y, p2->x, p2->y);
	}

	extern "C" void agg_path_curve(void* gr, REBINT rel, REBPAR* p1, REBPAR* p2, REBPAR* p3)
	{
		((agg_graphics*)gr)->agg_path_cubic_curve(rel, p1->x, p1->y, p2->x, p2->y, p3->x, p3->y);
	}

	extern "C" void agg_path_hline(void* gr, REBCNT rel, REBDEC x)
	{
		((agg_graphics*)gr)->agg_path_hline(rel, x); 
	}

	
	extern "C" void agg_path_line(void* gr, REBCNT rel, REBPAR* p)
	{
		((agg_graphics*)gr)->agg_path_line(rel, p->x, p->y); 
	}

	extern "C" void agg_path_move(void* gr, REBCNT rel, REBPAR* p)
	{
		((agg_graphics*)gr)->agg_path_move(rel, p->x, p->y);
	}

	extern "C" void agg_path_vline(void* gr, REBCNT rel, REBDEC y)
	{
		((agg_graphics*)gr)->agg_path_vline(rel, y); 
	}

	extern "C" void agg_path_qcurv(void* gr, REBINT rel, REBPAR* p)
	{
		((agg_graphics*)gr)->agg_path_quadratic_curve_to(rel, p->x, p->y);
	}

	extern "C" void agg_path_qcurve(void* gr, REBINT rel, REBPAR* p1, REBPAR* p2)
	{
		((agg_graphics*)gr)->agg_path_quadratic_curve(rel, p1->x, p1->y, p2->x, p2->y);
	}
#endif
}
